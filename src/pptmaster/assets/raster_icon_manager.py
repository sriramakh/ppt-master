"""Raster icon manager â€” loads manifest.json, provides search and retrieval."""

from __future__ import annotations

import json
from pathlib import Path
from typing import Any


DEFAULT_ICON_DIR = Path(__file__).resolve().parent.parent.parent.parent / "data" / "icons"


class RasterIconManager:
    """Manager for PNG icons generated by icon_generator.py."""

    def __init__(self, icon_dir: Path | str = DEFAULT_ICON_DIR):
        self.icon_dir = Path(icon_dir)
        self._manifest: dict[str, Any] | None = None
        self._index: dict[str, str] = {}  # name -> relative path
        self._load_manifest()

    def _load_manifest(self) -> None:
        """Load manifest.json if available."""
        manifest_path = self.icon_dir / "manifest.json"
        if not manifest_path.exists():
            return

        self._manifest = json.loads(manifest_path.read_text())

        # Build flat index
        for category, icons in self._manifest.get("categories", {}).items():
            for icon in icons:
                if icon.get("exists", False):
                    self._index[icon["name"]] = icon["file"]

    @property
    def available(self) -> bool:
        """Whether icons are available."""
        return bool(self._index)

    def get_icon_path(self, name: str) -> Path | None:
        """Get absolute path to an icon by name.

        Returns None if icon doesn't exist.
        """
        rel = self._index.get(name)
        if not rel:
            return None
        path = self.icon_dir / rel
        return path if path.exists() else None

    def search(self, query: str) -> list[dict[str, Any]]:
        """Search icons by name substring.

        Returns list of {name, category, path} dicts.
        """
        query_lower = query.lower()
        results = []

        if not self._manifest:
            return results

        for category, icons in self._manifest.get("categories", {}).items():
            for icon in icons:
                if query_lower in icon["name"].lower() and icon.get("exists", False):
                    results.append({
                        "name": icon["name"],
                        "category": category,
                        "path": str(self.icon_dir / icon["file"]),
                    })

        return results

    def get_by_category(self, category: str) -> list[dict[str, Any]]:
        """Get all icons in a category.

        Returns list of {name, path} dicts.
        """
        if not self._manifest:
            return []

        icons = self._manifest.get("categories", {}).get(category, [])
        results = []
        for icon in icons:
            if icon.get("exists", False):
                results.append({
                    "name": icon["name"],
                    "path": str(self.icon_dir / icon["file"]),
                })
        return results

    def list_categories(self) -> list[str]:
        """List all available categories."""
        if not self._manifest:
            return []
        return list(self._manifest.get("categories", {}).keys())

    def get_random_for_topic(self, topic: str, count: int = 6) -> list[dict[str, Any]]:
        """Get icons relevant to a topic by matching category or name.

        Falls back to random selection if no matches.
        """
        topic_lower = topic.lower()
        matches = []

        # First try category match
        for cat in self.list_categories():
            if cat in topic_lower or topic_lower in cat:
                matches.extend(self.get_by_category(cat))

        # Then try name search
        if len(matches) < count:
            for name in self._index:
                if topic_lower in name or any(w in name for w in topic_lower.split()):
                    path = self.get_icon_path(name)
                    if path and not any(m["name"] == name for m in matches):
                        matches.append({"name": name, "path": str(path)})

        # Fall back to first N icons
        if not matches:
            for name, rel in list(self._index.items())[:count]:
                matches.append({"name": name, "path": str(self.icon_dir / rel)})

        return matches[:count]


# Singleton instance
_manager: RasterIconManager | None = None


def get_icon_manager(icon_dir: Path | str = DEFAULT_ICON_DIR) -> RasterIconManager:
    """Get or create the singleton icon manager."""
    global _manager
    if _manager is None or str(_manager.icon_dir) != str(icon_dir):
        _manager = RasterIconManager(icon_dir)
    return _manager
